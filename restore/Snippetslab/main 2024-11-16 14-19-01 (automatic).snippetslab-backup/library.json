{
  "name" : "main.snippetslablibrary",
  "app" : "2.5.1",
  "contents" : {
    "snippets" : [
      {
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "fragments" : [
          {
            "dateCreated" : "2024-11-16T04:49:37Z",
            "language" : "SqlLexer",
            "dateModified" : "2024-11-16T05:17:07Z",
            "attachments" : [

            ],
            "uuid" : "7452F697-7CD3-46AF-A1FF-4208E7BE6D8F",
            "note" : "",
            "content" : "SELECT *\nFROM S\nWHERE SNAME IN (\n\tSELECT SNAME\n\tFROM S\n\tWHERE SNO = 0211\n);",
            "title" : "标签页"
          }
        ],
        "title" : "Sub",
        "dateCreated" : "2024-11-16T04:49:37Z",
        "uuid" : "7CADEBB3-BB5B-40E7-82DE-20B4C9E580D2",
        "dateModified" : "2024-11-16T05:17:17Z"
      },
      {
        "dateCreated" : "2024-10-17T13:11:42Z",
        "githubUsername" : "PaRr0tBoY",
        "dateModified" : "2024-11-16T05:03:16Z",
        "uuid" : "CF056C4C-49C9-49AF-A75B-9B21F414EEE4",
        "fragments" : [
          {
            "title" : "createSingleLinkedList.c",
            "note" : "作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/6231831f497642c10c31b7d12e68fc59)",
            "language" : "CLexer",
            "attachments" : [

            ],
            "uuid" : "54DE7CCB-5C4A-4EF9-B42F-8D7A75CE8EBD",
            "dateCreated" : "2024-10-17T13:11:42Z",
            "dateModified" : "2024-11-16T05:03:16Z",
            "content" : "struct Node{\n  int data;\n  LinkedList next;\n}Node, *LinkedList;\n\n\/\/with HEAD\n\n\/\/Create a single linked list with Hinsert\nLinkedList createList(){\n  \/\/Create HEAD NODE\n  Node *L;\n  L=(*Node)malloc(sizeof(Node));\n  L->Next=NULL;\n  \n  int x;\n  while(scanf(\"%d\", &x) != EOF){\n    Node *n;\n    n=(*Node)malloc(sizeof(Node));\n    n->data=x;\n    \/\/put n to the position where originally was HEAD\n    n->next=L->next;\n    \/\/put L back to the HEAD after inserting\n    L->next=p;\n  }\n  return L;\n}\n\n\/\/Create linked list from its tail\nLinkedList CreateList2(){\n  \n  \/\/create head node\n  Node *L;\n  L=(*Node)malloc(sizeof(Node));\n  L->next = NULL;\n  \n  \/\/create tail node\n  Node *r;\n  r = L;\n  \n  \/\/ask for user input\n  printf(\"请输入要插入链表的结点\\n\");\n  int x;\n  while(scanf(\"%d\", &x) != EOF){\n    Node* n;\n    n = (*Node)malloc(sizeof(Node));\n    \/\/while r is \"tail\" of linked list\n    \/\/link n to tail of linked list\n    r->next = n;\n    \/\/remap r to the tail of linked list\n    r = n;\n  }\n  \/\/since r is tail, so it point to NULL\n  r->next = NULL;\n  \/\/return linked list after inserting\n  return L;\n}\n\n\/\/another way\nLinkedList createLinkedList(){\n  Node *HEAD, *L, *NEW;\n  HEAD = (*Node)malloc(sizeof(Node));\n  L = HEAD;\n  L->next = NULL;\n  \n  int x;\n  while(scanf(\"%d\", &x){\n    NEW = (*Node)malloc(sizeof(Node));\n    NEW->data = x;\n    L->next = NEW;\n    NEW->next = NULL;\n    L = NEW;\n  }\n  return HEAD;\n}\n\/\/without HEAD\nLinkedList CreateLinkedList(){\n  Node *L, *HEAD, *LNEW;\n  HEAD = (*Node)malloc(sizeof(Node));\n  L = HEAD = NULL;\n  \n  int x;\n  while(scanf(\"%d\", &x){\n    LNEW = (*Node)malloc(sizeof(Node));\n    LNEW->data = x;\n    LNEW->next = NULL;\n    \n    \/\/Why L null?\n    if(L = NULL){\n      HEAD = L =LNEW;\n    }else L->next = LNEW;\n    L = LNEW;\n  }\n  return HEAD;\n}"
          }
        ],
        "gistIdentifier" : "6231831f497642c10c31b7d12e68fc59",
        "title" : "createSingleLinkedList.c",
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/6231831f497642c10c31b7d12e68fc59"
      },
      {
        "fragments" : [
          {
            "dateCreated" : "2024-10-17T11:50:03Z",
            "note" : "Init a linkedlist\n作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/541a10d2df17694d217aecc4ac5c5c58)",
            "uuid" : "4C074457-5AD4-4475-9541-3362BB0D1B12",
            "dateModified" : "2024-11-16T05:03:31Z",
            "content" : "typedef struct Node{\n  int data;\n  struct Node *next;\n}Node, *LinkList\n\/\/Node 表示结点的类型，Linklist 表示指向 Node 结点类型的指针\n\n# 单链表初始化\nLinklist listInit(){\n  Node *L;\n  L=(Node*)malloc(sizeof(Node));\n  if(L==NULL) printf(\"申请空间失败\"); \/\/一定要判断空间是否申请成功\n  L->NULL;\n}",
            "attachments" : [

            ],
            "language" : "CLexer",
            "title" : "linklist.c"
          }
        ],
        "githubUsername" : "PaRr0tBoY",
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/541a10d2df17694d217aecc4ac5c5c58",
        "dateModified" : "2024-11-16T05:03:31Z",
        "dateCreated" : "2024-10-17T11:50:03Z",
        "gistIdentifier" : "541a10d2df17694d217aecc4ac5c5c58",
        "title" : "linklist.c",
        "uuid" : "2D534555-C652-4829-9BDD-B82BB5C049E5"
      },
      {
        "uuid" : "37A896B2-4DDB-43A3-A23A-24C6AF63C346",
        "title" : "gistfile1.txt",
        "dateModified" : "2024-11-16T05:03:59Z",
        "gistIdentifier" : "53089c6a35932f7fafb5b86df898ba6d",
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/53089c6a35932f7fafb5b86df898ba6d",
        "dateCreated" : "2024-10-09T05:45:37Z",
        "githubUsername" : "PaRr0tBoY",
        "fragments" : [
          {
            "language" : "TextLexer",
            "note" : "test\n作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/53089c6a35932f7fafb5b86df898ba6d)",
            "content" : "www.ac1d.space\n",
            "dateCreated" : "2024-10-09T05:45:37Z",
            "uuid" : "5AEB4263-083C-471C-9A41-691ED3FF1EF6",
            "title" : "gistfile1.txt",
            "dateModified" : "2024-11-16T05:03:59Z",
            "attachments" : [

            ]
          }
        ]
      },
      {
        "dateCreated" : "2024-10-22T03:34:47Z",
        "gistIdentifier" : "68e5ecb67458558fa76f3cbca5ba56c4",
        "uuid" : "A3722136-31DC-412B-9A57-38EF9A5F83CC",
        "fragments" : [
          {
            "content" : "void printList(LinkedList L){\n    Node *p = L->next;\n    \/\/set a counter to showcase the sequence of each content\n    int i = 0;\n    while(p){\n        printf(\"第 %d 个元素的值为：%d\\n\", ++i, p->data);\n        p = p->next;\n}",
            "dateCreated" : "2024-10-22T03:34:47Z",
            "attachments" : [

            ],
            "title" : "printList.c",
            "note" : "作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/68e5ecb67458558fa76f3cbca5ba56c4)",
            "uuid" : "611AFC84-EA5C-42D8-9E49-898D726FA7E7",
            "dateModified" : "2024-11-16T05:03:01Z",
            "language" : "CLexer"
          }
        ],
        "dateModified" : "2024-11-16T05:03:01Z",
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/68e5ecb67458558fa76f3cbca5ba56c4",
        "githubUsername" : "PaRr0tBoY",
        "title" : "printList.c"
      },
      {
        "uuid" : "073BC0CA-E6AE-4BE9-987F-DCE10BA1081F",
        "title" : "gistfile1.txt",
        "dateModified" : "2024-11-16T05:03:46Z",
        "githubUsername" : "PaRr0tBoY",
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/e7496a236f1bad34da0cee2f42d2db56",
        "fragments" : [
          {
            "dateCreated" : "2024-10-10T08:51:30Z",
            "note" : "最大子列和问题\n作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/e7496a236f1bad34da0cee2f42d2db56)",
            "content" : "#include <stdio.h>\n\nint maxSubSeqSumlogn(int A[], int N);\nint maxSubSeqSumn2(int A[], int N);\nint DivideAndConquer(int A[], int Left, int Right);\nint MaxSum(int a, int b, int c);\n\n\nint main()\n{\n\tint A[10];\n\tfor(int i = 0; i < 10; i++){\n\t\tscanf(\"%d\", &A[i]);\n\t}\n\tprintf(\"%d\", maxSubSeqSumlogn(A, 10));\n\treturn 0;\n}\n\nint maxSubSeqSumn2(int A[], int N){\n\tint i, j, thisSum, maxSum = 0;\n\t\/\/i 代表子列左端位置，j 代表子列右端位置\n\tfor(i = 0; i < N; i++){\n\t\/\/初始化 thisSum 为 0\n\t\/\/thisSum是从 A[i]到 A[j]的和\n\t\/\/初始化的目的是当子列左端位置改变时重新开始计算 thisSum\n\tthisSum = 0;\n\t\tfor(j = i; j < N; j++){\n\t\t\tthisSum += A[j];\n\t\t\tif(thisSum > maxSum){\n\t\t\t\tmaxSum = thisSum;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxSum;\n}\n\n\n\/*\n1. 编写函数时，首先考虑返回值\n\ta. 返回类型\n\tb. return 的变量\n2. 然后考虑函数名，尽量体现函数的功能\n3. 接着考虑需要哪些参数\n\ta. 参数类型\n\tb. 参数个数\n4. 考虑函数体实现\n\ta. 局部变量的声明、初始化、使用\n\tb. for\/if\/else\/while\/switch\n\tc. 函数的框架\n总结\n返回值\/函数目标->函数名\/说明->参数\/函数需求->函数体\/具体实现\n*\/\n\nint DivideAndConquer(int A[], int Left, int Right){\n\t\/\/声明存储左右最大子列结果的变量\n\tint MaxLeftSum, MaxRightSum;\n\t\/\/声明存储跨分割线子列结果的变量\n\tint MaxLeftBorderSum, MaxRightBorderSum;\n\t\/\/声明临时存储跨分割线子列和的变量\n\tint LeftBorderSum, RightBorderSum;\n\t\/\/其他要声明的变量,考虑for循环的变量i,j,...\n\tint Center, i;\n\n\t\/\/将要求和的子列从中间分割，分别计算左、右、跨分割线的子列和，然后比较得出最大的子列和\n\t\/\/不断递归将子列拆分为更小的子列，直到子列只剩下一个数，然后再层层合并结果，最终合而治之\n\t\/\/递归要求有结束条件，如下递归的趋势是左位置越来越接近右位置，右位置不可超越到左位置的左边\n\t\/\/因此至少是 Right >= Left, 结束条件会是破坏此状态的临界点\n\tif(Right == Left){\n\t\/\/如果递归终止条件触发，那么左右位置必定相等，这时如果子列此位置值大于 0 可以任意返回一边，否则返回0\n\t\tif(A[Left] > 0) return A[Left];\n\t\telse return 0;\n\t}\n\n\tCenter = (Left + Right) \/ 2;\n\t\/\/函数定义时，编写的参数是形参，需要明确定义传入参数的类型和名字，例如 int List[]\n\t\/\/但是调用函数时，传入的实参，是一个实际上存在的参数，因此传入数组时可以直接写 List，因为c中数组是指针\n\tMaxLeftSum = DivideAndConquer(A, Left, Center);\n\tMaxRightSum = DivideAndConquer(A, Center + 1, Right);\n\n\t\/\/接下来计算跨分割线的子列和，参考上一个函数的实现\n\t\/\/计算左子列分割线的子列和\n\tLeftBorderSum = 0; MaxLeftBorderSum = 0;\n\tfor(i = Center; i >= Left; i--){\n\t\tLeftBorderSum += A[i];\n\t\tif(LeftBorderSum > MaxLeftBorderSum)\n\t\t\tMaxLeftBorderSum = LeftBorderSum;\n\t}\n\n\t\/\/计算右子列分割线的子列和\n\tRightBorderSum = 0; MaxRightBorderSum = 0;\n\tfor(i = Center + 1; i <= Right; i++){\n\t\tRightBorderSum += A[i];\n\t\tif(RightBorderSum > MaxRightBorderSum)\n\t\t\tMaxRightBorderSum = RightBorderSum;\n\t}\n\n\t\/\/返回治的结果\n\treturn MaxSum(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);\n}\n\nint MaxSum(int a, int b, int c){\n\treturn a > b ? a > c ? a : c : b > c ? b : c;\n}\n\nint maxSubSeqSumlogn(int A[], int N){\n\treturn DivideAndConquer(A, 0, N-1);\n}\n\n\/*\n大化小，然后分而治之\n*\/\n\n\/\/实时处理\nint maxSubSeqSumn(int A[], int N){\n\tint thisSum, maxSum;\n\t\/\/所有程序都声明一个i,用于潜在的for循环\n\tint i;\n\tthisSum = maxSum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tthisSum += A[i];\n\t\t\/\/如果当前子列和大于最大子列和，则更新最大子列和\n\t\tif(thisSum > maxSum)\n\t\t\tmaxSum = thisSum;\n\t\t\/\/如果当前子列和小于0，则重新开始计算子列和\n\t\t\/\/因为如果当前子列和小于0，那么它对后续子列和的贡献必定为负，因此需要重新开始计算\n\t\telse if(thisSum < 0)\n\t\t\tthisSum = 0;\n\t}\n\treturn maxSum;\n}\n\n\/\/ n² 的算法\nint maxSubSeqSumn2(int A[], int N){\n\tint i, j, thisSum, maxSum;\n\t\/\/初始化最大子列和为0,c语言中变量未初始化时，值是不确定的，因此需要初始化\n\tmaxSum = 0;\n\tfor(i = 0; i < N; i++){\n\t\t\/\/初始化当前子列和为0\n\t\tthisSum = 0;\n\t\tfor(j = i; j < N; j++){\n\t\t\tthisSum += A[j];\n\t\t\t\/\/如果当前子列和大于最大子列和，则更新最大子列和\n\t\t\tif(thisSum > maxSum)\n\t\t\t\tmaxSum = thisSum;\n\t\t}\n\t}\n\treturn maxSum;\n}",
            "language" : "TextLexer",
            "title" : "gistfile1.txt",
            "attachments" : [

            ],
            "dateModified" : "2024-11-16T05:03:46Z",
            "uuid" : "A14E4569-D0E1-4EEF-A668-2CCAD4A3E2B2"
          }
        ],
        "dateCreated" : "2024-10-10T08:51:30Z",
        "gistIdentifier" : "e7496a236f1bad34da0cee2f42d2db56"
      },
      {
        "title" : "editLinkedList.c",
        "dateCreated" : "2024-10-22T03:41:59Z",
        "gistIdentifier" : "cb03322444fd2c8e69df72fa2e48f29b",
        "dateModified" : "2024-11-16T05:02:40Z",
        "uuid" : "B3BD4BC4-2F89-4080-9FC3-6F4790FBC6AA",
        "githubUsername" : "PaRr0tBoY",
        "fragments" : [
          {
            "content" : "\/\/This function return a LinkedList type,which is the edited version of the original linkedlist\nLinkedList editLinkedList(int x, int k, LinkedList L){\n\t\/\/Create a pointer to locate the head of current linkedlist\n\tNode *p = L->next;\n\t\/\/if p not null which indicates that there are still unvisited nodes in L;\n\twhile(p){\n\t\tif(p->data == x) p->data = k;\n\t\tp = p->next;\n\t}\n\treturn L;\n}",
            "dateModified" : "2024-11-16T05:02:40Z",
            "note" : "作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/cb03322444fd2c8e69df72fa2e48f29b)",
            "dateCreated" : "2024-10-22T03:41:59Z",
            "uuid" : "2B9E1432-9789-449F-ADDB-84F8410714B7",
            "title" : "editLinkedList.c",
            "attachments" : [

            ],
            "language" : "CLexer"
          }
        ],
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/cb03322444fd2c8e69df72fa2e48f29b"
      },
      {
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "uuid" : "4C948DA2-4B0E-4A47-974B-62CC87907ABA",
        "title" : "Join1",
        "dateCreated" : "2024-11-16T05:13:32Z",
        "fragments" : [
          {
            "title" : "标签页",
            "language" : "SqlLexer",
            "content" : "SELECT *\nFROM S\n\tINNER JOIN C ON S.SNO = C.SNO\nWHERE SNAME = 'QWE';",
            "dateModified" : "2024-11-16T05:18:06Z",
            "note" : "",
            "uuid" : "E1E073C5-ABAD-488C-95ED-6407EF9C98AE",
            "attachments" : [

            ],
            "dateCreated" : "2024-11-16T05:13:32Z"
          }
        ],
        "dateModified" : "2024-11-16T05:18:09Z"
      },
      {
        "fragments" : [
          {
            "attachments" : [

            ],
            "content" : "SELECT *\nFROM S\n\tINNER JOIN C ON S.SNO = C.SNO\n\tINNER JOIN SC ON SC.CNO = C.CNO\nWHERE SNAME = 'QWE';",
            "note" : "",
            "language" : "SqlLexer",
            "uuid" : "E1D741BC-59D9-45EA-B048-92D0840FC8B2",
            "title" : "标签页",
            "dateCreated" : "2024-11-16T05:18:10Z",
            "dateModified" : "2024-11-16T05:18:18Z"
          }
        ],
        "uuid" : "CBF52727-58BA-4442-A2EA-DF38C8D806AF",
        "title" : "Join2",
        "dateModified" : "2024-11-16T05:18:12Z",
        "dateCreated" : "2024-11-16T05:18:10Z",
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8"
      },
      {
        "title" : "View",
        "uuid" : "375A2B96-51C8-4E45-B49C-969CD071EB89",
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "dateModified" : "2024-11-16T05:22:22Z",
        "fragments" : [
          {
            "content" : "CREATE VIEW V_C\nAS\nSELECT S.SNO, SNAME, GRADE\nFROM S INNER JOIN SC\nON S.SNO = SC.SNO\nWHERE CNO = (\n    SELECT CNO\n    FROM C\n    WHERE CNAME = '高等数学'\n    )\nWITH CHECK OPTION;\n\nSELECT *\nFROM V_C;",
            "title" : "标签页",
            "dateModified" : "2024-11-16T05:23:30Z",
            "dateCreated" : "2024-11-16T05:22:20Z",
            "language" : "SqlLexer",
            "attachments" : [

            ],
            "uuid" : "318C5CC5-67A1-4378-9DA6-6A7253809A67",
            "note" : ""
          }
        ],
        "dateCreated" : "2024-11-16T05:22:20Z"
      },
      {
        "uuid" : "4F403AB5-583C-4C89-AB22-3DB7428E01BD",
        "fragments" : [
          {
            "uuid" : "F738E82E-FF70-4E18-A7C5-CD9DE965206D",
            "language" : "SqlLexer",
            "attachments" : [

            ],
            "note" : "",
            "dateModified" : "2024-11-16T06:04:39Z",
            "content" : "CREATE UNIQUE INDEX I_C\nON C(CNAME DESC);",
            "title" : "标签页",
            "dateCreated" : "2024-11-16T05:22:36Z"
          }
        ],
        "title" : "Index",
        "dateCreated" : "2024-11-16T05:22:36Z",
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "dateModified" : "2024-11-16T05:22:43Z"
      },
      {
        "dateModified" : "2024-11-16T05:25:14Z",
        "title" : "Universal",
        "uuid" : "72874D46-265B-40F8-A1F5-CEA62A56DC7F",
        "fragments" : [
          {
            "dateCreated" : "2024-11-16T05:25:02Z",
            "uuid" : "380BE348-D2FE-4572-8E38-97CFC5EBFA54",
            "title" : "标签页",
            "language" : "SqlLexer",
            "dateModified" : "2024-11-16T05:25:36Z",
            "content" : "SELECT *\nFROM SC\nWHERE \nGROUP BY \nHAVING\nORDER BY\nLIMIT number;",
            "attachments" : [

            ],
            "note" : ""
          }
        ],
        "dateCreated" : "2024-11-16T05:25:02Z",
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8"
      },
      {
        "fragments" : [
          {
            "note" : "",
            "language" : "SqlLexer",
            "content" : "CREATE PROCEDURE PC_NP\n    @LastName nvarchar(50),\n    @FirstName nvarchar(50)\nAS   \n    SELECT FirstName, LastName, CompanyName\n    FROM SalesLT.Customer\n    WHERE FirstName = @FirstName AND LastName = @LastName;\nGO\nEXEC PC_NP N'Cannon', N'Chris';\nEXEC PC_NP @FirstName = N'Chris', @LastName = N'Cannon';\nGO",
            "title" : "标签页",
            "uuid" : "69BE3C17-639E-4FEC-B9BA-F0A8EC97D933",
            "dateModified" : "2024-11-16T05:42:28Z",
            "attachments" : [

            ],
            "dateCreated" : "2024-11-16T05:29:23Z"
          }
        ],
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "uuid" : "9ABC90F5-92E1-4929-9259-20BFE1F252B1",
        "title" : "Proc",
        "dateModified" : "2024-11-16T05:29:29Z",
        "dateCreated" : "2024-11-16T05:29:23Z"
      },
      {
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "dateModified" : "2024-11-16T05:29:33Z",
        "fragments" : [
          {
            "dateCreated" : "2024-11-16T05:29:30Z",
            "content" : "CREATE TRIGGER TR_NT\nON TABLE_NAME\nFOR\/AFTER\/\/INSTEAD OF UPDATE,INSERT,DELETE\nAS\nBEGIN\n    IF EXISTS (\n        SELECT *\n        FROM S\n        WHERE SNAME = '123'\n    )\n    BEGIN\n    \tPRINT 'test';\n        ROLLBACK TRANSACTION;\n    END\nEND;",
            "attachments" : [

            ],
            "dateModified" : "2024-11-16T05:58:45Z",
            "uuid" : "C2393484-31BF-4A82-9ED6-79F220E72C05",
            "language" : "SqlLexer",
            "note" : "",
            "title" : "标签页"
          }
        ],
        "dateCreated" : "2024-11-16T05:29:30Z",
        "title" : "Trigger",
        "uuid" : "CD3B1332-7756-470A-9FC9-ABA0A1693089"
      },
      {
        "dateModified" : "2024-11-16T05:43:44Z",
        "title" : "聚集函数",
        "dateCreated" : "2024-11-16T05:43:40Z",
        "uuid" : "AEA66922-3610-4CC2-873E-FABE5849E83D",
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "fragments" : [
          {
            "note" : "",
            "dateCreated" : "2024-11-16T05:43:40Z",
            "uuid" : "BAA9D279-F54C-4BF6-8E00-4C4C3C077540",
            "language" : "MarkdownLexer",
            "content" : "| **聚集函数**   | **作用**                                                         | **示例**                                                                |\n|----------------|------------------------------------------------------------------|-------------------------------------------------------------------------|\n| **`COUNT()`**  | 计算指定列或整个表的行数（可用于 `DISTINCT`）。                   | `SELECT COUNT(*) FROM Employees;`                                      |\n| **`SUM()`**    | 计算指定列的数值总和。                                           | `SELECT SUM(Salary) FROM Employees;`                                   |\n| **`AVG()`**    | 计算指定列的平均值。                                             | `SELECT AVG(Salary) FROM Employees;`                                    |\n| **`MIN()`**    | 返回指定列中的最小值。                                           | `SELECT MIN(Salary) FROM Employees;`                                    |\n| **`MAX()`**    | 返回指定列中的最大值。                                           | `SELECT MAX(Salary) FROM Employees;`                                    |\n| **`GROUP_CONCAT()`** | 将多个行的值合并为一个字符串（MySQL 特有函数）。              | `SELECT GROUP_CONCAT(Name) FROM Employees;`                             |\n| **`FIRST()`**  | 返回某列的第一个值（某些数据库系统中使用）。                     | `SELECT FIRST(Name) FROM Employees;` (某些数据库特有，如 MS SQL Server) |\n| **`LAST()`**   | 返回某列的最后一个值（某些数据库系统中使用）。                   | `SELECT LAST(Name) FROM Employees;` (某些数据库特有，如 MS SQL Server)  |\n| **`VARIANCE()`** | 计算某列的方差。                                                | `SELECT VARIANCE(Salary) FROM Employees;`                               |\n| **`STDDEV()`** | 计算某列的标准差。                                               | `SELECT STDDEV(Salary) FROM Employees;`                                 |",
            "attachments" : [

            ],
            "dateModified" : "2024-11-16T06:03:26Z",
            "title" : "标签页"
          }
        ]
      },
      {
        "title" : "TABLE",
        "dateCreated" : "2024-11-16T05:46:05Z",
        "dateModified" : "2024-11-16T05:46:07Z",
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "uuid" : "CB6561DB-80A7-41E4-9CB5-401A4353266D",
        "fragments" : [
          {
            "dateModified" : "2024-11-16T05:50:19Z",
            "uuid" : "9F60E85D-2785-4208-8CD4-7A839CDDD34B",
            "dateCreated" : "2024-11-16T05:46:05Z",
            "language" : "SqlLexer",
            "attachments" : [

            ],
            "content" : "CREATE TABLE SampleTable (\n    ID INT IDENTITY(1,1) PRIMARY KEY, --主键\n    Name NVARCHAR(100) NOT NULL,\n    Age INT CHECK (Age >= 0 AND Age <= 150), --带约束的证书\n    Salary DECIMAL(18, 2) DEFAULT 0.00, --精确小数\n    CreatedAt DATETIME DEFAULT GETDATE(), --自动填充当前时间\n    UpdatedAt DATETIME NULL, --记录更新时间\n    IsActive BIT DEFAULT 1, --默认值为 1\n    DepartmentID INT NOT NULL, --外键\n    Email NVARCHAR(255) UNIQUE, --唯一约束，邮箱值不可重复\n);\n\nALTER TABLE SampleTable --编辑表\nADD CONSTRAINT FK_SampleTable_Department FOREIGN KEY (DepartmentID) --设置外键 DepartmentID\nREFERENCES Departments(ID); --引用 Departments 表",
            "note" : "",
            "title" : "标签页"
          }
        ]
      },
      {
        "title" : "谓词",
        "fragments" : [
          {
            "content" : "| **谓词**          | **作用**                                                                                 | **示例**                                                        |\n|-------------------|------------------------------------------------------------------------------------------|-----------------------------------------------------------------|\n| **`=`**           | 检查两个值是否相等。                                                                      | `SELECT * FROM Employees WHERE Age = 30;`                      |\n| **`<>` 或 `!=`**   | 检查两个值是否不相等。                                                                   | `SELECT * FROM Employees WHERE Age <> 30;`                     |\n| **`>`**           | 检查左边的值是否大于右边的值。                                                           | `SELECT * FROM Employees WHERE Salary > 50000;`                |\n| **`<`**           | 检查左边的值是否小于右边的值。                                                           | `SELECT * FROM Employees WHERE Age < 40;`                      |\n| **`>=`**          | 检查左边的值是否大于或等于右边的值。                                                     | `SELECT * FROM Employees WHERE Age >= 30;`                     |\n| **`<=`**          | 检查左边的值是否小于或等于右边的值。                                                     | `SELECT * FROM Employees WHERE Salary <= 50000;`               |\n| **`BETWEEN`**     | 检查某个值是否在两个值之间（包含边界值）。                                               | `SELECT * FROM Employees WHERE Age BETWEEN 30 AND 40;`         |\n| **`NOT BETWEEN`** | 检查某个值是否不在两个值之间。                                                           | `SELECT * FROM Employees WHERE Age NOT BETWEEN 30 AND 40;`     |\n| **`IN`**          | 检查某个值是否存在于给定的集合中。                                                       | `SELECT * FROM Employees WHERE Department IN ('HR', 'Finance');`|\n| **`NOT IN`**      | 检查某个值是否不在给定的集合中。                                                         | `SELECT * FROM Employees WHERE Department NOT IN ('HR', 'Finance');`|\n| **`IS NULL`**     | 检查某个字段的值是否为 `NULL`。                                                           | `SELECT * FROM Employees WHERE Salary IS NULL;`                 |\n| **`IS NOT NULL`** | 检查某个字段的值是否不为 `NULL`。                                                         | `SELECT * FROM Employees WHERE Salary IS NOT NULL;`             |\n| **`LIKE`**        | 检查字符串是否匹配指定的模式（常用于模糊匹配）。                                         | `SELECT * FROM Employees WHERE Name LIKE 'J%';`                 |\n| **`NOT LIKE`**    | 检查字符串是否不匹配指定的模式。                                                         | `SELECT * FROM Employees WHERE Name NOT LIKE 'J%';`             |\n| **`EXISTS`**      | 检查子查询是否返回至少一行数据。                                                         | `SELECT * FROM Employees WHERE EXISTS (SELECT * FROM Departments WHERE ID = Employees.DepartmentID);`|\n| **`NOT EXISTS`**  | 检查子查询是否没有返回任何数据。                                                         | `SELECT * FROM Employees WHERE NOT EXISTS (SELECT * FROM Departments WHERE ID = Employees.DepartmentID);`|\n| **`AND`**         | 连接多个条件，要求所有条件都为 `TRUE`。                                                 | `SELECT * FROM Employees WHERE Age > 30 AND Department = 'HR';`|\n| **`OR`**          | 连接多个条件，要求至少有一个条件为 `TRUE`。                                             | `SELECT * FROM Employees WHERE Age > 30 OR Department = 'HR';` |\n| **`NOT`**         | 否定条件，要求条件为 `FALSE`。                                                           | `SELECT * FROM Employees WHERE NOT Age > 30;`                   |",
            "attachments" : [

            ],
            "language" : "MarkdownLexer",
            "uuid" : "B7203CD6-D4BF-439C-86C7-D93A47E2690E",
            "note" : "",
            "dateModified" : "2024-11-16T06:02:20Z",
            "dateCreated" : "2024-11-16T06:00:56Z",
            "title" : "标签页"
          }
        ],
        "uuid" : "235D68AC-D402-414E-A9D6-DC937186A4E7",
        "dateModified" : "2024-11-16T06:01:08Z",
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "dateCreated" : "2024-11-16T06:00:56Z"
      }
    ],
    "folders" : [
      {
        "uuid" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "title" : "SQL"
      }
    ],
    "smartGroups" : [

    ],
    "attachments" : [

    ],
    "tags" : [

    ],
    "shortcuts" : [

    ]
  },
  "date" : "2024-11-16T06:19:01Z",
  "snippets" : 17,
  "modified" : "2024-11-16T06:01:08Z",
  "schema" : "2.4"
}