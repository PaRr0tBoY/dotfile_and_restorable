{
  "modified" : "2024-11-16T05:18:12Z",
  "contents" : {
    "folders" : [
      {
        "uuid" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "title" : "SQL"
      }
    ],
    "snippets" : [
      {
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "fragments" : [
          {
            "title" : "标签页",
            "content" : "SELECT *\nFROM S\nWHERE SNAME IN (\n\tSELECT SNAME\n\tFROM S\n\tWHERE SNO = 0211\n);",
            "note" : "",
            "dateCreated" : "2024-11-16T04:49:37Z",
            "dateModified" : "2024-11-16T05:17:07Z",
            "language" : "SqlLexer",
            "uuid" : "7452F697-7CD3-46AF-A1FF-4208E7BE6D8F",
            "attachments" : [

            ]
          }
        ],
        "dateCreated" : "2024-11-16T04:49:37Z",
        "dateModified" : "2024-11-16T05:17:17Z",
        "uuid" : "7CADEBB3-BB5B-40E7-82DE-20B4C9E580D2",
        "title" : "Sub"
      },
      {
        "gistIdentifier" : "6231831f497642c10c31b7d12e68fc59",
        "dateCreated" : "2024-10-17T13:11:42Z",
        "githubUsername" : "PaRr0tBoY",
        "fragments" : [
          {
            "content" : "struct Node{\n  int data;\n  LinkedList next;\n}Node, *LinkedList;\n\n\/\/with HEAD\n\n\/\/Create a single linked list with Hinsert\nLinkedList createList(){\n  \/\/Create HEAD NODE\n  Node *L;\n  L=(*Node)malloc(sizeof(Node));\n  L->Next=NULL;\n  \n  int x;\n  while(scanf(\"%d\", &x) != EOF){\n    Node *n;\n    n=(*Node)malloc(sizeof(Node));\n    n->data=x;\n    \/\/put n to the position where originally was HEAD\n    n->next=L->next;\n    \/\/put L back to the HEAD after inserting\n    L->next=p;\n  }\n  return L;\n}\n\n\/\/Create linked list from its tail\nLinkedList CreateList2(){\n  \n  \/\/create head node\n  Node *L;\n  L=(*Node)malloc(sizeof(Node));\n  L->next = NULL;\n  \n  \/\/create tail node\n  Node *r;\n  r = L;\n  \n  \/\/ask for user input\n  printf(\"请输入要插入链表的结点\\n\");\n  int x;\n  while(scanf(\"%d\", &x) != EOF){\n    Node* n;\n    n = (*Node)malloc(sizeof(Node));\n    \/\/while r is \"tail\" of linked list\n    \/\/link n to tail of linked list\n    r->next = n;\n    \/\/remap r to the tail of linked list\n    r = n;\n  }\n  \/\/since r is tail, so it point to NULL\n  r->next = NULL;\n  \/\/return linked list after inserting\n  return L;\n}\n\n\/\/another way\nLinkedList createLinkedList(){\n  Node *HEAD, *L, *NEW;\n  HEAD = (*Node)malloc(sizeof(Node));\n  L = HEAD;\n  L->next = NULL;\n  \n  int x;\n  while(scanf(\"%d\", &x){\n    NEW = (*Node)malloc(sizeof(Node));\n    NEW->data = x;\n    L->next = NEW;\n    NEW->next = NULL;\n    L = NEW;\n  }\n  return HEAD;\n}\n\/\/without HEAD\nLinkedList CreateLinkedList(){\n  Node *L, *HEAD, *LNEW;\n  HEAD = (*Node)malloc(sizeof(Node));\n  L = HEAD = NULL;\n  \n  int x;\n  while(scanf(\"%d\", &x){\n    LNEW = (*Node)malloc(sizeof(Node));\n    LNEW->data = x;\n    LNEW->next = NULL;\n    \n    \/\/Why L null?\n    if(L = NULL){\n      HEAD = L =LNEW;\n    }else L->next = LNEW;\n    L = LNEW;\n  }\n  return HEAD;\n}",
            "uuid" : "54DE7CCB-5C4A-4EF9-B42F-8D7A75CE8EBD",
            "dateCreated" : "2024-10-17T13:11:42Z",
            "dateModified" : "2024-11-16T05:03:16Z",
            "note" : "作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/6231831f497642c10c31b7d12e68fc59)",
            "title" : "createSingleLinkedList.c",
            "language" : "CLexer",
            "attachments" : [

            ]
          }
        ],
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/6231831f497642c10c31b7d12e68fc59",
        "dateModified" : "2024-11-16T05:03:16Z",
        "uuid" : "CF056C4C-49C9-49AF-A75B-9B21F414EEE4",
        "title" : "createSingleLinkedList.c"
      },
      {
        "fragments" : [
          {
            "language" : "CLexer",
            "attachments" : [

            ],
            "uuid" : "4C074457-5AD4-4475-9541-3362BB0D1B12",
            "dateCreated" : "2024-10-17T11:50:03Z",
            "title" : "linklist.c",
            "dateModified" : "2024-11-16T05:03:31Z",
            "note" : "Init a linkedlist\n作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/541a10d2df17694d217aecc4ac5c5c58)",
            "content" : "typedef struct Node{\n  int data;\n  struct Node *next;\n}Node, *LinkList\n\/\/Node 表示结点的类型，Linklist 表示指向 Node 结点类型的指针\n\n# 单链表初始化\nLinklist listInit(){\n  Node *L;\n  L=(Node*)malloc(sizeof(Node));\n  if(L==NULL) printf(\"申请空间失败\"); \/\/一定要判断空间是否申请成功\n  L->NULL;\n}"
          }
        ],
        "dateModified" : "2024-11-16T05:03:31Z",
        "dateCreated" : "2024-10-17T11:50:03Z",
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/541a10d2df17694d217aecc4ac5c5c58",
        "gistIdentifier" : "541a10d2df17694d217aecc4ac5c5c58",
        "uuid" : "2D534555-C652-4829-9BDD-B82BB5C049E5",
        "title" : "linklist.c",
        "githubUsername" : "PaRr0tBoY"
      },
      {
        "uuid" : "37A896B2-4DDB-43A3-A23A-24C6AF63C346",
        "title" : "gistfile1.txt",
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/53089c6a35932f7fafb5b86df898ba6d",
        "githubUsername" : "PaRr0tBoY",
        "gistIdentifier" : "53089c6a35932f7fafb5b86df898ba6d",
        "dateCreated" : "2024-10-09T05:45:37Z",
        "fragments" : [
          {
            "title" : "gistfile1.txt",
            "attachments" : [

            ],
            "dateCreated" : "2024-10-09T05:45:37Z",
            "uuid" : "5AEB4263-083C-471C-9A41-691ED3FF1EF6",
            "note" : "test\n作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/53089c6a35932f7fafb5b86df898ba6d)",
            "language" : "TextLexer",
            "content" : "www.ac1d.space\n",
            "dateModified" : "2024-11-16T05:03:59Z"
          }
        ],
        "dateModified" : "2024-11-16T05:03:59Z"
      },
      {
        "uuid" : "A3722136-31DC-412B-9A57-38EF9A5F83CC",
        "gistIdentifier" : "68e5ecb67458558fa76f3cbca5ba56c4",
        "fragments" : [
          {
            "language" : "CLexer",
            "dateModified" : "2024-11-16T05:03:01Z",
            "content" : "void printList(LinkedList L){\n    Node *p = L->next;\n    \/\/set a counter to showcase the sequence of each content\n    int i = 0;\n    while(p){\n        printf(\"第 %d 个元素的值为：%d\\n\", ++i, p->data);\n        p = p->next;\n}",
            "dateCreated" : "2024-10-22T03:34:47Z",
            "title" : "printList.c",
            "note" : "作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/68e5ecb67458558fa76f3cbca5ba56c4)",
            "uuid" : "611AFC84-EA5C-42D8-9E49-898D726FA7E7",
            "attachments" : [

            ]
          }
        ],
        "githubUsername" : "PaRr0tBoY",
        "dateCreated" : "2024-10-22T03:34:47Z",
        "title" : "printList.c",
        "dateModified" : "2024-11-16T05:03:01Z",
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/68e5ecb67458558fa76f3cbca5ba56c4"
      },
      {
        "gistIdentifier" : "e7496a236f1bad34da0cee2f42d2db56",
        "githubUsername" : "PaRr0tBoY",
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/e7496a236f1bad34da0cee2f42d2db56",
        "title" : "gistfile1.txt",
        "dateModified" : "2024-11-16T05:03:46Z",
        "fragments" : [
          {
            "note" : "最大子列和问题\n作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/e7496a236f1bad34da0cee2f42d2db56)",
            "attachments" : [

            ],
            "content" : "#include <stdio.h>\n\nint maxSubSeqSumlogn(int A[], int N);\nint maxSubSeqSumn2(int A[], int N);\nint DivideAndConquer(int A[], int Left, int Right);\nint MaxSum(int a, int b, int c);\n\n\nint main()\n{\n\tint A[10];\n\tfor(int i = 0; i < 10; i++){\n\t\tscanf(\"%d\", &A[i]);\n\t}\n\tprintf(\"%d\", maxSubSeqSumlogn(A, 10));\n\treturn 0;\n}\n\nint maxSubSeqSumn2(int A[], int N){\n\tint i, j, thisSum, maxSum = 0;\n\t\/\/i 代表子列左端位置，j 代表子列右端位置\n\tfor(i = 0; i < N; i++){\n\t\/\/初始化 thisSum 为 0\n\t\/\/thisSum是从 A[i]到 A[j]的和\n\t\/\/初始化的目的是当子列左端位置改变时重新开始计算 thisSum\n\tthisSum = 0;\n\t\tfor(j = i; j < N; j++){\n\t\t\tthisSum += A[j];\n\t\t\tif(thisSum > maxSum){\n\t\t\t\tmaxSum = thisSum;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxSum;\n}\n\n\n\/*\n1. 编写函数时，首先考虑返回值\n\ta. 返回类型\n\tb. return 的变量\n2. 然后考虑函数名，尽量体现函数的功能\n3. 接着考虑需要哪些参数\n\ta. 参数类型\n\tb. 参数个数\n4. 考虑函数体实现\n\ta. 局部变量的声明、初始化、使用\n\tb. for\/if\/else\/while\/switch\n\tc. 函数的框架\n总结\n返回值\/函数目标->函数名\/说明->参数\/函数需求->函数体\/具体实现\n*\/\n\nint DivideAndConquer(int A[], int Left, int Right){\n\t\/\/声明存储左右最大子列结果的变量\n\tint MaxLeftSum, MaxRightSum;\n\t\/\/声明存储跨分割线子列结果的变量\n\tint MaxLeftBorderSum, MaxRightBorderSum;\n\t\/\/声明临时存储跨分割线子列和的变量\n\tint LeftBorderSum, RightBorderSum;\n\t\/\/其他要声明的变量,考虑for循环的变量i,j,...\n\tint Center, i;\n\n\t\/\/将要求和的子列从中间分割，分别计算左、右、跨分割线的子列和，然后比较得出最大的子列和\n\t\/\/不断递归将子列拆分为更小的子列，直到子列只剩下一个数，然后再层层合并结果，最终合而治之\n\t\/\/递归要求有结束条件，如下递归的趋势是左位置越来越接近右位置，右位置不可超越到左位置的左边\n\t\/\/因此至少是 Right >= Left, 结束条件会是破坏此状态的临界点\n\tif(Right == Left){\n\t\/\/如果递归终止条件触发，那么左右位置必定相等，这时如果子列此位置值大于 0 可以任意返回一边，否则返回0\n\t\tif(A[Left] > 0) return A[Left];\n\t\telse return 0;\n\t}\n\n\tCenter = (Left + Right) \/ 2;\n\t\/\/函数定义时，编写的参数是形参，需要明确定义传入参数的类型和名字，例如 int List[]\n\t\/\/但是调用函数时，传入的实参，是一个实际上存在的参数，因此传入数组时可以直接写 List，因为c中数组是指针\n\tMaxLeftSum = DivideAndConquer(A, Left, Center);\n\tMaxRightSum = DivideAndConquer(A, Center + 1, Right);\n\n\t\/\/接下来计算跨分割线的子列和，参考上一个函数的实现\n\t\/\/计算左子列分割线的子列和\n\tLeftBorderSum = 0; MaxLeftBorderSum = 0;\n\tfor(i = Center; i >= Left; i--){\n\t\tLeftBorderSum += A[i];\n\t\tif(LeftBorderSum > MaxLeftBorderSum)\n\t\t\tMaxLeftBorderSum = LeftBorderSum;\n\t}\n\n\t\/\/计算右子列分割线的子列和\n\tRightBorderSum = 0; MaxRightBorderSum = 0;\n\tfor(i = Center + 1; i <= Right; i++){\n\t\tRightBorderSum += A[i];\n\t\tif(RightBorderSum > MaxRightBorderSum)\n\t\t\tMaxRightBorderSum = RightBorderSum;\n\t}\n\n\t\/\/返回治的结果\n\treturn MaxSum(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);\n}\n\nint MaxSum(int a, int b, int c){\n\treturn a > b ? a > c ? a : c : b > c ? b : c;\n}\n\nint maxSubSeqSumlogn(int A[], int N){\n\treturn DivideAndConquer(A, 0, N-1);\n}\n\n\/*\n大化小，然后分而治之\n*\/\n\n\/\/实时处理\nint maxSubSeqSumn(int A[], int N){\n\tint thisSum, maxSum;\n\t\/\/所有程序都声明一个i,用于潜在的for循环\n\tint i;\n\tthisSum = maxSum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tthisSum += A[i];\n\t\t\/\/如果当前子列和大于最大子列和，则更新最大子列和\n\t\tif(thisSum > maxSum)\n\t\t\tmaxSum = thisSum;\n\t\t\/\/如果当前子列和小于0，则重新开始计算子列和\n\t\t\/\/因为如果当前子列和小于0，那么它对后续子列和的贡献必定为负，因此需要重新开始计算\n\t\telse if(thisSum < 0)\n\t\t\tthisSum = 0;\n\t}\n\treturn maxSum;\n}\n\n\/\/ n² 的算法\nint maxSubSeqSumn2(int A[], int N){\n\tint i, j, thisSum, maxSum;\n\t\/\/初始化最大子列和为0,c语言中变量未初始化时，值是不确定的，因此需要初始化\n\tmaxSum = 0;\n\tfor(i = 0; i < N; i++){\n\t\t\/\/初始化当前子列和为0\n\t\tthisSum = 0;\n\t\tfor(j = i; j < N; j++){\n\t\t\tthisSum += A[j];\n\t\t\t\/\/如果当前子列和大于最大子列和，则更新最大子列和\n\t\t\tif(thisSum > maxSum)\n\t\t\t\tmaxSum = thisSum;\n\t\t}\n\t}\n\treturn maxSum;\n}",
            "dateModified" : "2024-11-16T05:03:46Z",
            "uuid" : "A14E4569-D0E1-4EEF-A668-2CCAD4A3E2B2",
            "language" : "TextLexer",
            "dateCreated" : "2024-10-10T08:51:30Z",
            "title" : "gistfile1.txt"
          }
        ],
        "uuid" : "073BC0CA-E6AE-4BE9-987F-DCE10BA1081F",
        "dateCreated" : "2024-10-10T08:51:30Z"
      },
      {
        "githubHTMLURL" : "https:\/\/gist.github.com\/PaRr0tBoY\/cb03322444fd2c8e69df72fa2e48f29b",
        "gistIdentifier" : "cb03322444fd2c8e69df72fa2e48f29b",
        "githubUsername" : "PaRr0tBoY",
        "title" : "editLinkedList.c",
        "fragments" : [
          {
            "uuid" : "2B9E1432-9789-449F-ADDB-84F8410714B7",
            "attachments" : [

            ],
            "dateCreated" : "2024-10-22T03:41:59Z",
            "language" : "CLexer",
            "dateModified" : "2024-11-16T05:02:40Z",
            "note" : "作者: PaRr0tBoY (https:\/\/gist.github.com\/PaRr0tBoY\/cb03322444fd2c8e69df72fa2e48f29b)",
            "title" : "editLinkedList.c",
            "content" : "\/\/This function return a LinkedList type,which is the edited version of the original linkedlist\nLinkedList editLinkedList(int x, int k, LinkedList L){\n\t\/\/Create a pointer to locate the head of current linkedlist\n\tNode *p = L->next;\n\t\/\/if p not null which indicates that there are still unvisited nodes in L;\n\twhile(p){\n\t\tif(p->data == x) p->data = k;\n\t\tp = p->next;\n\t}\n\treturn L;\n}"
          }
        ],
        "dateModified" : "2024-11-16T05:02:40Z",
        "uuid" : "B3BD4BC4-2F89-4080-9FC3-6F4790FBC6AA",
        "dateCreated" : "2024-10-22T03:41:59Z"
      },
      {
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "fragments" : [
          {
            "language" : "SqlLexer",
            "dateCreated" : "2024-11-16T05:13:32Z",
            "title" : "标签页",
            "uuid" : "E1E073C5-ABAD-488C-95ED-6407EF9C98AE",
            "note" : "",
            "attachments" : [

            ],
            "dateModified" : "2024-11-16T05:18:06Z",
            "content" : "SELECT *\nFROM S\n\tINNER JOIN C ON S.SNO = C.SNO\nWHERE SNAME = 'QWE';"
          }
        ],
        "dateModified" : "2024-11-16T05:18:09Z",
        "title" : "Join1",
        "uuid" : "4C948DA2-4B0E-4A47-974B-62CC87907ABA",
        "dateCreated" : "2024-11-16T05:13:32Z"
      },
      {
        "title" : "Join2",
        "folder" : "A1DA3859-C9AE-45FD-A435-BC9410F448B8",
        "dateModified" : "2024-11-16T05:18:12Z",
        "fragments" : [
          {
            "dateCreated" : "2024-11-16T05:18:10Z",
            "language" : "SqlLexer",
            "title" : "标签页",
            "dateModified" : "2024-11-16T05:18:18Z",
            "note" : "",
            "attachments" : [

            ],
            "uuid" : "E1D741BC-59D9-45EA-B048-92D0840FC8B2",
            "content" : "SELECT *\nFROM S\n\tINNER JOIN C ON S.SNO = C.SNO\n\tINNER JOIN SC ON SC.CNO = C.CNO\nWHERE SNAME = 'QWE';"
          }
        ],
        "uuid" : "CBF52727-58BA-4442-A2EA-DF38C8D806AF",
        "dateCreated" : "2024-11-16T05:18:10Z"
      }
    ],
    "tags" : [

    ],
    "attachments" : [

    ],
    "shortcuts" : [

    ],
    "smartGroups" : [

    ]
  },
  "name" : "main.snippetslablibrary",
  "date" : "2024-11-16T05:19:01Z",
  "snippets" : 9,
  "app" : "2.5.1",
  "schema" : "2.4"
}